# 패킷을 송수신하는 동작에서 서버와 클라이언트의 차이가 있습니까?

서버는 하드웨어나 os 부분은 클라이언트와 다르더라도 결국 **네트워크 관한 부분( LAN 어뎁터) , 프로토콜 스택, Soket라이브러리 등의 기능**은 클라이언트와 조금도 다르지 않습니다.

서버는 네트워크 상에서 항상 대기하며, 클라이언트의 요청을 받으면 해당 요청에 대한 응답을 생성하여 클라이언트에게 보냅니다.

클라이언트는 사용자가 서버에게 어떤 동작을 요청하는 것으로, 요청을 생성하고 서버에 전송하여 결과를 받는 역할을 합니다. 클라이언트는 서버로부터 받은 응답을 해석하고 필요에 따라 사용자에게 표시하는 역할을 담당합니다.

밑에서 더자세히 다룰 예정.
> 서버 : socket() 생성 → bind() 소켓 주소할당 → listen() 연결요청 대기상태 → accept() 연결허용 → read/write() 데이터 송수신 → close() 연결종료

> 클라이언트 : socket() 생성 → connect() 연결요청 → read/write() 데이터 송수신 → close() 연결종료

클라이언트 소켓을 생성한 후, 서버로 연결을 요청하는 과정에서 차이가 존재합니다.

서버는 listen() 호출 이후부터 연결요청 대기 큐를 만들어 놓고, 그 이후에 클라이언트가 연결 요청을 할 수 있다. 이때 서버가 바로 accept()를 호출할 수 있는데, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 됩니다.


**참고로 Tcp는 흐름제어와 혼잡제어를 지원해서 데이터 순서를 보장해줍니다.
**
# 서버의 수신 동작

Layer 3 -> Layer 4

- ip 헤더를 조사해서 나에게 오는 패킷인지 확인합니다.헤더에는 목적지 IP 주소가 포함되어 있습니다. 이를 통해 패킷이 수신자의 IP 주소와 일치하는지 확인합니다.
- fragmentation 필드를 통해 패킷이 분할되었는지 여부와 각 분할된 패킷의 오프셋 등의 정보를 확인할 수 있습니다.된 패킷인지 판단한 후 L4에게 전달합니다.


Layer 4 -> 애플리케이션

- 목적지 포트 번호를 확인하여 해당 프로토콜을 식별하고, 패킷을 적절한 애플리케이션에 전달합니다

## 소켓의 동작 과정
두 개의  프로세스가 소켓을 통해 네트워크 연결(Connection)을 만들기 위해서는, 최초 어느 한 곳에서 그 대상이 되는 곳으로 연결을 요청해야 합니다. IP 주소와 포트 번호로 식별되는 대상에게, 자신이 데이터 송수신을 위한 네트워크 연결을 수립할 의사가 있음을 알리는 것이입니다.

이 둘을 클라이언트 소켓(Client Socket)과 서버 소켓(Server Socket)으로 본다면 이 둘의 소켓은 별개의 소캣이 아닌 **같은 소캣**입니다. 역할에 따라 다른 api를 호출 하거나 순서가 다를 뿐입니다.

소켓 연결이 완료된 다음 클라이언트 소켓과 서버 소켓이 직접 데이터를 주고 받는다고 생각하는 것은 아닙니다.
서버 소켓은 클라이언트 소켓의 연결 요청을 받아들이는 역할만 수행할 뿐, 직접적인 데이터 송수신은 서버 소켓의 연결 요청 수락의 결과로 만들어지는 새로운 소켓을 통해 처리됩니다.

### 소켓의 API 실행 흐름
위에도 있지만 더 자세히 소켓의 흐름을 정리해 보겠습니다.

- 클라이언트 소켓(Client Socket)은
1.처음 소켓을 생성(create)
2.서버 측에 연결(connect)을 요청합니다.
3.그리고 서버 소켓에서 연결이 받아들여지면 데이터를 송수신(send/recv)하고, 모든 처리가 완료되면
4.소켓 을 닫습니다(close).

- 서버 소켓(Server Socket)은 
1.처음 소켓을 생성(create)
2.서버가 사용할 IP와 포트번호를 생성한 소켓에 결합(bind) :  인자로 소켓(Socket)과 포트 번호(또는 IP 주소+포트 번호) 받습니다. 일반적으로 소버 소켓은 고정된 포트번호를 사용합니다. 그리고 그 포트 번호로 클라이언트 연결 요청을 받아들입니다.
3.클라이언트로부터 연결 요청이 수신되는지 주시(liten)
4.요청이 수신되면 받아들여(accept) 데이터 통신을 위한 소켓을 생성합니다.
5.일단 새로운 소켓을 통해 연결이 수립 되면, 클라이언트와 마찬가지로 데이터를 송수신(send/recv)할 수있습니다.
6.마지막으로 데이터 송수신이 완료되면, 소켓을 닫습니다(close).







> 참고자료 : 
https://engineering.linecorp.com/ko/blog/reactive-streams-with-armeria-1
https://recipes4dev.tistory.com/153
